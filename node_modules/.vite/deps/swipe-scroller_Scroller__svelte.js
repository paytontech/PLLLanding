import "./chunk-X7HCJ7ZS.js";
import "./chunk-W54PNBU6.js";
import {
  SvelteComponentDev,
  add_location,
  append_hydration_dev,
  append_styles,
  attr_dev,
  binding_callbacks,
  bubble,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_svg_element,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  get_all_dirty_from_scope,
  get_slot_changes,
  group_outros,
  init,
  insert_hydration_dev,
  listen_dev,
  mount_component,
  noop,
  onMount,
  run_all,
  safe_not_equal,
  set_style,
  space,
  svg_element,
  toggle_class,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-HPG2YY3T.js";
import "./chunk-2AFTNLNW.js";
import "./chunk-25V3TAZK.js";

// node_modules/swipe-scroller/dist/Chevron.svelte
var file = "node_modules/swipe-scroller/dist/Chevron.svelte";
function create_fragment(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        fill: true,
        viewBox: true,
        "stroke-width": true,
        stroke: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", {
        "stroke-linecap": true,
        "stroke-linejoin": true,
        d: true
      });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "stroke-linecap", "round");
      attr_dev(path, "stroke-linejoin", "round");
      attr_dev(
        path,
        "d",
        /*d*/
        ctx[0]
      );
      add_location(path, file, 11, 1, 240);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke-width", "3");
      attr_dev(svg, "stroke", "currentColor");
      add_location(svg, file, 4, 0, 121);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Chevron", slots, []);
  let { left = true } = $$props;
  const d = left ? "M15.75 19.5L8.25 12l7.5-7.5" : "M8.25 4.5l7.5 7.5-7.5 7.5";
  const writable_props = ["left"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Chevron> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("left" in $$props2)
      $$invalidate(1, left = $$props2.left);
  };
  $$self.$capture_state = () => ({ left, d });
  $$self.$inject_state = ($$props2) => {
    if ("left" in $$props2)
      $$invalidate(1, left = $$props2.left);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [d, left];
}
var Chevron = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { left: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Chevron",
      options,
      id: create_fragment.name
    });
  }
  get left() {
    throw new Error("<Chevron>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set left(value) {
    throw new Error("<Chevron>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Chevron_default = Chevron;

// node_modules/swipe-scroller/dist/Scroller.svelte
var file2 = "node_modules/swipe-scroller/dist/Scroller.svelte";
function add_css(target) {
  append_styles(target, "svelte-6vkmhv", "noscript.svelte-6vkmhv.svelte-6vkmhv{display:block;margin-bottom:0.625rem}.scroller-wrapper.svelte-6vkmhv.svelte-6vkmhv{position:relative}.scroller.svelte-6vkmhv.svelte-6vkmhv{display:flex;gap:var(--slide-gap);padding:0 var(--scroller-offset);scroll-padding-left:var(--scroller-offset);overflow-x:visible}.scroller.svelte-6vkmhv > *{flex-shrink:0;scroll-snap-align:start}.scroller-js.svelte-6vkmhv.svelte-6vkmhv{overflow-x:auto;scroll-behavior:smooth;scroll-snap-type:x mandatory;scrollbar-width:none}.scroller-js.svelte-6vkmhv.svelte-6vkmhv::-webkit-scrollbar{display:none}.scroller-control.svelte-6vkmhv.svelte-6vkmhv{background-color:transparent;pointer-events:none;position:absolute;top:0;left:0;right:0;bottom:0;display:flex;align-items:center;justify-items:center;justify-content:space-between;opacity:0}.scroller-control.svelte-6vkmhv>button.svelte-6vkmhv{all:unset;cursor:pointer;pointer-events:auto}.scroller-control.container-inner.svelte-6vkmhv.svelte-6vkmhv{--button-margin:calc(var(--button-width) / -2)}.scroller-control.container-outer.svelte-6vkmhv.svelte-6vkmhv{--button-margin:calc(var(--button-width) / 2 * var(--button-margin-multiplier, 1))}.icon-wrapper.svelte-6vkmhv.svelte-6vkmhv{border-radius:100%;height:var(--button-width);width:var(--button-width);padding:calc(var(--button-width) / 4);background-color:rgba(0, 0, 0, 0.2);color:white}@media(hover: hover) and (pointer: fine){.scroller-wrapper.svelte-6vkmhv:hover .scroller-control.svelte-6vkmhv{opacity:1}.icon-wrapper.svelte-6vkmhv.svelte-6vkmhv:hover{background-color:rgba(0, 0, 0, 0.4)}}@media(prefers-reduced-motion: no-preference){.scroller-control.svelte-6vkmhv.svelte-6vkmhv{transition:opacity 150ms}.icon-wrapper.svelte-6vkmhv.svelte-6vkmhv{transition:background-color 150ms}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2Nyb2xsZXIuc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL3BheXRvbmRldi9Eb2N1bWVudHMvcGxsLXNvY2lhbC13ZWIvbm9kZV9tb2R1bGVzL3N3aXBlLXNjcm9sbGVyL2Rpc3QvU2Nyb2xsZXIuc3ZlbHRlIl19 */");
}
var get_button_next_slot_changes = (dirty) => ({});
var get_button_next_slot_context = (ctx) => ({});
var get_button_prev_slot_changes = (dirty) => ({});
var get_button_prev_slot_context = (ctx) => ({});
var get_noscript_slot_changes = (dirty) => ({});
var get_noscript_slot_context = (ctx) => ({});
function create_if_block(ctx) {
  let div;
  let button0;
  let button0_aria_label_value;
  let t;
  let button1;
  let button1_aria_label_value;
  let current;
  let mounted;
  let dispose;
  const button_prev_slot_template = (
    /*#slots*/
    ctx[10]["button-prev"]
  );
  const button_prev_slot = create_slot(
    button_prev_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_button_prev_slot_context
  );
  const button_prev_slot_or_fallback = button_prev_slot || fallback_block_1(ctx);
  const button_next_slot_template = (
    /*#slots*/
    ctx[10]["button-next"]
  );
  const button_next_slot = create_slot(
    button_next_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_button_next_slot_context
  );
  const button_next_slot_or_fallback = button_next_slot || fallback_block(ctx);
  const block = {
    c: function create() {
      div = element("div");
      button0 = element("button");
      if (button_prev_slot_or_fallback)
        button_prev_slot_or_fallback.c();
      t = space();
      button1 = element("button");
      if (button_next_slot_or_fallback)
        button_next_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div);
      button0 = claim_element(div_nodes, "BUTTON", {
        type: true,
        tabindex: true,
        "aria-label": true,
        style: true,
        class: true
      });
      var button0_nodes = children(button0);
      if (button_prev_slot_or_fallback)
        button_prev_slot_or_fallback.l(button0_nodes);
      button0_nodes.forEach(detach_dev);
      t = claim_space(div_nodes);
      button1 = claim_element(div_nodes, "BUTTON", {
        type: true,
        tabindex: true,
        "aria-label": true,
        style: true,
        class: true
      });
      var button1_nodes = children(button1);
      if (button_next_slot_or_fallback)
        button_next_slot_or_fallback.l(button1_nodes);
      button1_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button0, "type", "button");
      attr_dev(button0, "tabindex", "-1");
      attr_dev(button0, "aria-label", button0_aria_label_value = !/*invertButtons*/
      ctx[3] ? "Scroll Left" : "Scroll Right");
      set_style(button0, "margin-left", "var(--button-margin)");
      attr_dev(button0, "class", "svelte-6vkmhv");
      add_location(button0, file2, 50, 3, 1409);
      attr_dev(button1, "type", "button");
      attr_dev(button1, "tabindex", "-1");
      attr_dev(button1, "aria-label", button1_aria_label_value = !/*invertButtons*/
      ctx[3] ? "Scroll Right" : "Scroll Left");
      set_style(button1, "margin-right", "var(--button-margin)");
      attr_dev(button1, "class", "svelte-6vkmhv");
      add_location(button1, file2, 63, 3, 1720);
      attr_dev(div, "class", "scroller-control svelte-6vkmhv");
      set_style(
        div,
        "--button-width",
        /*buttonWidth*/
        ctx[0]
      );
      toggle_class(
        div,
        "container-outer",
        /*hangButtons*/
        ctx[2]
      );
      toggle_class(div, "container-inner", !/*hangButtons*/
      ctx[2]);
      add_location(div, file2, 44, 2, 1248);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, button0);
      if (button_prev_slot_or_fallback) {
        button_prev_slot_or_fallback.m(button0, null);
      }
      append_hydration_dev(div, t);
      append_hydration_dev(div, button1);
      if (button_next_slot_or_fallback) {
        button_next_slot_or_fallback.m(button1, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button0,
            "click",
            /*click_handler*/
            ctx[15],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button1,
            "click",
            /*click_handler_1*/
            ctx[16],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (button_prev_slot) {
        if (button_prev_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            button_prev_slot,
            button_prev_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              button_prev_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_button_prev_slot_changes
            ),
            get_button_prev_slot_context
          );
        }
      }
      if (!current || dirty & /*invertButtons*/
      8 && button0_aria_label_value !== (button0_aria_label_value = !/*invertButtons*/
      ctx2[3] ? "Scroll Left" : "Scroll Right")) {
        attr_dev(button0, "aria-label", button0_aria_label_value);
      }
      if (button_next_slot) {
        if (button_next_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            button_next_slot,
            button_next_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              button_next_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_button_next_slot_changes
            ),
            get_button_next_slot_context
          );
        }
      }
      if (!current || dirty & /*invertButtons*/
      8 && button1_aria_label_value !== (button1_aria_label_value = !/*invertButtons*/
      ctx2[3] ? "Scroll Right" : "Scroll Left")) {
        attr_dev(button1, "aria-label", button1_aria_label_value);
      }
      if (!current || dirty & /*buttonWidth*/
      1) {
        set_style(
          div,
          "--button-width",
          /*buttonWidth*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*hangButtons*/
      4) {
        toggle_class(
          div,
          "container-outer",
          /*hangButtons*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*hangButtons*/
      4) {
        toggle_class(div, "container-inner", !/*hangButtons*/
        ctx2[2]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button_prev_slot_or_fallback, local);
      transition_in(button_next_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button_prev_slot_or_fallback, local);
      transition_out(button_next_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (button_prev_slot_or_fallback)
        button_prev_slot_or_fallback.d(detaching);
      if (button_next_slot_or_fallback)
        button_next_slot_or_fallback.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(44:1) {#if offsetLeft !== undefined}",
    ctx
  });
  return block;
}
function fallback_block_1(ctx) {
  let div;
  let chevron;
  let current;
  chevron = new Chevron_default({ $$inline: true });
  const block = {
    c: function create() {
      div = element("div");
      create_component(chevron.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(chevron.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "icon-wrapper svelte-6vkmhv");
      add_location(div, file2, 58, 5, 1635);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(chevron, div, null);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(chevron.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chevron.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(chevron);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_1.name,
    type: "fallback",
    source: "(58:29)       ",
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let div;
  let chevron;
  let current;
  chevron = new Chevron_default({ props: { left: false }, $$inline: true });
  const block = {
    c: function create() {
      div = element("div");
      create_component(chevron.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(chevron.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "icon-wrapper svelte-6vkmhv");
      add_location(div, file2, 71, 5, 1952);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(chevron, div, null);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current)
        return;
      transition_in(chevron.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chevron.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(chevron);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(71:29)       ",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let div4;
  let div1;
  let t0;
  let div0;
  let t1;
  let div3;
  let div2;
  let t2;
  let current;
  let mounted;
  let dispose;
  const noscript_slot_template = (
    /*#slots*/
    ctx[10].noscript
  );
  const noscript_slot = create_slot(
    noscript_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_noscript_slot_context
  );
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let if_block = (
    /*offsetLeft*/
    ctx[5] !== void 0 && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      div4 = element("div");
      div1 = element("div");
      if (noscript_slot)
        noscript_slot.c();
      t0 = space();
      div0 = element("div");
      t1 = space();
      div3 = element("div");
      div2 = element("div");
      if (default_slot)
        default_slot.c();
      t2 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div4 = claim_element(nodes, "DIV", { class: true });
      var div4_nodes = children(div4);
      div1 = claim_element(div4_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (noscript_slot)
        noscript_slot.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", {});
      children(div0).forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      t1 = claim_space(div4_nodes);
      div3 = claim_element(div4_nodes, "DIV", {});
      var div3_nodes = children(div3);
      div2 = claim_element(div3_nodes, "DIV", { class: true, style: true });
      var div2_nodes = children(div2);
      if (default_slot)
        default_slot.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      t2 = claim_space(div4_nodes);
      if (if_block)
        if_block.l(div4_nodes);
      div4_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(div0, file2, 27, 2, 875);
      attr_dev(div1, "class", "container-inner");
      add_location(div1, file2, 23, 1, 724);
      attr_dev(div2, "class", "scroller svelte-6vkmhv");
      set_style(
        div2,
        "--slide-gap",
        /*cardGap*/
        ctx[1]
      );
      set_style(
        div2,
        "--scroller-offset",
        /*offsetLeft*/
        (ctx[5] || 0) + "px"
      );
      toggle_class(
        div2,
        "scroller-js",
        /*offsetLeft*/
        ctx[5] !== void 0
      );
      add_location(div2, file2, 31, 2, 979);
      toggle_class(
        div3,
        "container-inner",
        /*offsetLeft*/
        ctx[5] === void 0
      );
      add_location(div3, file2, 30, 1, 922);
      attr_dev(div4, "class", "scroller-wrapper svelte-6vkmhv");
      add_location(div4, file2, 22, 0, 692);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div4, anchor);
      append_hydration_dev(div4, div1);
      if (noscript_slot) {
        noscript_slot.m(div1, null);
      }
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      ctx[13](div0);
      append_hydration_dev(div4, t1);
      append_hydration_dev(div4, div3);
      append_hydration_dev(div3, div2);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      ctx[14](div2);
      append_hydration_dev(div4, t2);
      if (if_block)
        if_block.m(div4, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window,
            "resize",
            /*updateOffsetLeft*/
            ctx[7],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "scroll",
            /*scroll_handler*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "scrollend",
            /*scrollend_handler*/
            ctx[12],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (noscript_slot) {
        if (noscript_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            noscript_slot,
            noscript_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              noscript_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_noscript_slot_changes
            ),
            get_noscript_slot_context
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*cardGap*/
      2) {
        set_style(
          div2,
          "--slide-gap",
          /*cardGap*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*offsetLeft*/
      32) {
        set_style(
          div2,
          "--scroller-offset",
          /*offsetLeft*/
          (ctx2[5] || 0) + "px"
        );
      }
      if (!current || dirty & /*offsetLeft, undefined*/
      32) {
        toggle_class(
          div2,
          "scroller-js",
          /*offsetLeft*/
          ctx2[5] !== void 0
        );
      }
      if (!current || dirty & /*offsetLeft, undefined*/
      32) {
        toggle_class(
          div3,
          "container-inner",
          /*offsetLeft*/
          ctx2[5] === void 0
        );
      }
      if (
        /*offsetLeft*/
        ctx2[5] !== void 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*offsetLeft*/
          32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div4, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(noscript_slot, local);
      transition_in(default_slot, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(noscript_slot, local);
      transition_out(default_slot, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div4);
      }
      if (noscript_slot)
        noscript_slot.d(detaching);
      ctx[13](null);
      if (default_slot)
        default_slot.d(detaching);
      ctx[14](null);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Scroller", slots, ["noscript", "default", "button-prev", "button-next"]);
  let { buttonWidth = "2.5rem" } = $$props;
  let { cardGap = "1.25rem" } = $$props;
  let { hangButtons = true } = $$props;
  let { invertButtons = false } = $$props;
  let referenceElement;
  let offsetLeft;
  const updateOffsetLeft = () => $$invalidate(5, offsetLeft = referenceElement == null ? void 0 : referenceElement.offsetLeft);
  onMount(updateOffsetLeft);
  let scroller;
  const scroll = (left = true) => {
    var _a;
    const width = (_a = scroller.firstElementChild) == null ? void 0 : _a.getBoundingClientRect().width;
    if (!width)
      return;
    const directionMultiplier = (left ? -1 : 1) * (invertButtons ? -1 : 1);
    $$invalidate(6, scroller.scrollLeft += directionMultiplier * width, scroller);
  };
  const writable_props = ["buttonWidth", "cardGap", "hangButtons", "invertButtons"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Scroller> was created with unknown prop '${key}'`);
  });
  function scroll_handler(event) {
    bubble.call(this, $$self, event);
  }
  function scrollend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      referenceElement = $$value;
      $$invalidate(4, referenceElement);
    });
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      scroller = $$value;
      $$invalidate(6, scroller);
    });
  }
  const click_handler = () => scroll();
  const click_handler_1 = () => scroll(false);
  $$self.$$set = ($$props2) => {
    if ("buttonWidth" in $$props2)
      $$invalidate(0, buttonWidth = $$props2.buttonWidth);
    if ("cardGap" in $$props2)
      $$invalidate(1, cardGap = $$props2.cardGap);
    if ("hangButtons" in $$props2)
      $$invalidate(2, hangButtons = $$props2.hangButtons);
    if ("invertButtons" in $$props2)
      $$invalidate(3, invertButtons = $$props2.invertButtons);
    if ("$$scope" in $$props2)
      $$invalidate(9, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    Chevron: Chevron_default,
    buttonWidth,
    cardGap,
    hangButtons,
    invertButtons,
    referenceElement,
    offsetLeft,
    updateOffsetLeft,
    scroller,
    scroll
  });
  $$self.$inject_state = ($$props2) => {
    if ("buttonWidth" in $$props2)
      $$invalidate(0, buttonWidth = $$props2.buttonWidth);
    if ("cardGap" in $$props2)
      $$invalidate(1, cardGap = $$props2.cardGap);
    if ("hangButtons" in $$props2)
      $$invalidate(2, hangButtons = $$props2.hangButtons);
    if ("invertButtons" in $$props2)
      $$invalidate(3, invertButtons = $$props2.invertButtons);
    if ("referenceElement" in $$props2)
      $$invalidate(4, referenceElement = $$props2.referenceElement);
    if ("offsetLeft" in $$props2)
      $$invalidate(5, offsetLeft = $$props2.offsetLeft);
    if ("scroller" in $$props2)
      $$invalidate(6, scroller = $$props2.scroller);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    buttonWidth,
    cardGap,
    hangButtons,
    invertButtons,
    referenceElement,
    offsetLeft,
    scroller,
    updateOffsetLeft,
    scroll,
    $$scope,
    slots,
    scroll_handler,
    scrollend_handler,
    div0_binding,
    div2_binding,
    click_handler,
    click_handler_1
  ];
}
var Scroller = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        buttonWidth: 0,
        cardGap: 1,
        hangButtons: 2,
        invertButtons: 3
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Scroller",
      options,
      id: create_fragment2.name
    });
  }
  get buttonWidth() {
    throw new Error("<Scroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonWidth(value) {
    throw new Error("<Scroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cardGap() {
    throw new Error("<Scroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cardGap(value) {
    throw new Error("<Scroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hangButtons() {
    throw new Error("<Scroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hangButtons(value) {
    throw new Error("<Scroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invertButtons() {
    throw new Error("<Scroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invertButtons(value) {
    throw new Error("<Scroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Scroller_default = Scroller;
export {
  Scroller_default as default
};
//# sourceMappingURL=swipe-scroller_Scroller__svelte.js.map
